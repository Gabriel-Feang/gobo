# Gobo ðŸ’

*"Gobo, isolate the behaviors you want. Stop stubbing when you can simulate intelligent behavior."*

Gobo is a lightweight Go library for intercepting HTTP requests and substituting them with intelligent, context-aware mock responses generated by an LLM.

Instead of hard-coding JSON stubs, you define the **expected struct schema** with `gobo` struct tags and let the LLM generate realistic responses.

## For AI Integration Agents (MCP)
If you are an AI test-runner agent using MCP, Gobo is **designed specifically for you**.

Start the target application with Gobo, and it will "pause" every HTTP call until youâ€”the Agentâ€”fulfill it via MCP tools (`get_pending_requests` / `submit_response`).

---

## Installation

```bash
go get github.com/gabriel-feang/gobo
```

## Quick Start â€” Handler-based API

The simplest way to use Gobo. Register routes inline with `http.ServeMux`:

```go
package main

import (
	"log"
	"net/http"
	"github.com/gabriel-feang/gobo"
	gobomcp "github.com/gabriel-feang/gobo/mcp"
)

type HealthResponse struct {
	Status string `json:"status" gobo:"Always 'healthy'"`
}

type UserResponse struct {
	ID    string `json:"id" gobo:"A UUID v4"`
	Name  string `json:"name" gobo:"A creative internet handle"`
	Email string `json:"email" gobo:"A valid email for a tech company"`
}

func main() {
	// One-liner setup â€” MCP starts on stdio automatically
	g := gobo.New(gobomcp.WithMCP())

	mux := http.NewServeMux()
	mux.Handle("GET /health", g.Stub(HealthResponse{Status: "healthy"}))
	mux.Handle("GET /api/users", g.Intercept(realUsersHandler(), UserResponse{}))

	log.Fatal(http.ListenAndServe(":9060", mux))
}

func realUsersHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(`{"id":"real","name":"real-user","email":"real@co.com"}`))
	})
}
```

### Handler Methods

- **`g.Stub(schema)`** â€” For mock-only routes (no real handler). Uses the generator to produce responses. When no generator is configured, marshals the schema as static JSON.

- **`g.Intercept(handler, schema)`** â€” Wraps a real handler. When a generator is active, intercepts and generates a response. When no generator, passes through to the real handler.

## Functional Options

```go
// Use Ollama for LLM-generated responses
g := gobo.New(gobo.WithOllama("http://localhost:11434", "llama3"))

// Use a custom generator
g := gobo.New(gobo.WithGenerator(myGenerator))

// Enable debug logging
g := gobo.New(gobo.WithDebug())

// Backward-compatible Config struct
g := gobo.New(gobo.WithConfig(gobo.Config{
	OllamaURL: "http://localhost:11434",
	Model:     "llama3",
	Debug:     true,
}))
```

## Middleware API (still supported)

The original `Register()` + `Middleware()` approach still works:

```go
mock := gobo.New(gobo.WithOllama("http://localhost:11434", "llama3"))

mock.Register("POST", "/v1/charge", PaymentResponse{})

ts := httptest.NewServer(mock.Middleware(http.NewServeMux()))
defer ts.Close()
```

## Dynamic Prompt Engineering (`gobo` Tags)

Gobo parses your structs using Go reflection. The `gobo` struct tag provides field-level instructions to the LLM:

```go
type User struct {
    ID    string `json:"id" gobo:"A UUID"`
    Name  string `json:"name" gobo:"A creative internet handle"`
    Email string `json:"email" gobo:"A valid email for a tech company"`
}
```

---

## Advanced: The `AsyncBroker` (For Testing Agents)

The `AsyncBroker` implements Gobo's `Generator` interface by parking intercepted HTTP requests indefinitely, waiting for an external system to submit the response.

```go
broker := gobo.NewAsyncBroker()

mock := gobo.New(gobo.WithGenerator(broker))
mock.Register("GET", "/users", UserSchema{})
ts := httptest.NewServer(mock.Middleware(http.NewServeMux()))

// ... Meanwhile, in another goroutine or via an Agent MCP Tool:
pending := broker.GetPendingRequests()

if len(pending) > 0 {
    fmt.Println(pending[0].Context.URL)
    broker.SubmitResponse(pending[0].ID, []byte(`{"id": "mocked-by-agent"}`))
}
```

## Custom LLMs (`Generator` Interface)

Wire up OpenAI, Anthropic, or any other LLM by implementing `Generator`:

```go
type Generator interface {
	GenerateResponse(ctx context.Context, reqCtx RequestContext, schema any) ([]byte, error)
}
```
